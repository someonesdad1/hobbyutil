'''
Make a file of specified size.
 
The random bytes functionality is done a byte at a time, so it can be
pretty slow.  Here's some timing on my computer on Sun 27 Jun 2010 02:18:15
PM:
 
    Not random
      For chunksize = 1e5
          1M                  0.2 s
          1G                  8.4 s
      For chunksize = 1e6
          1M                  0.2 s
          1G                  8.3 s
    Random (thus, about 200 kbytes/s)
      For chunksize = 1e5
          1M                  4.9 s
          10M                47.6 s
      For chunksize = 1e6
          1M                  5.0 s
          10M                47.8 s
 
2 May 2011:  I changed the random implmentation to use numpy to generate
the random integers.  Times in s on quad core Intel machine with Win XP:
    Not random
      For chunksize = 1e5
          1M                  0.32, 0.28, 0.29
          1G                  7.4, 6.6, 6.9
    Random
      For chunksize = 1e5
          1M                  0.98, 0.95, 0.95
          10M                 7.0, 7.0, 7.0
Thus, numpy gave a speedup of about 7 times.
 
4 Dec 2012:  With the same computer, the random bytes of 100 MB size
took 67.5 s.  It occurred to me that this is a perfect application for
os.urandom; it has the benefit that the generated bytes are touted to
be cryptographically secure.  Thus, this also doubles as a one time
pad generator.  The generation time for 100 MB stayed the same as the
numpy implementation.
'''
# Copyright (C) 2014 Don Peterson
# Contact:  gmail.com@someonesdad1

#
# Licensed under the Open Software License version 3.0.
# See http://opensource.org/licenses/OSL-3.0.
#
 
from __future__ import print_function, division
import sys
import getopt
import os
import random
from pdb import set_trace as xx
if 1:
    import debug
    debug.SetDebugger()

chunksize = int(1e5)
debug = 0   # Turns on debug printing
nl = "\n"

manual = '''Usage: %s [options] size filename
  Makes a file of specified size.  size is in bytes and can have the
  SI suffixes k, M, or G (no space between the letter and number).
 
Options:
    -b n
        Fill with byte value n.  n can be decimal, octal (start with
        '0'), or hex (start with 0x).  The default fill value is 0.
    -r
        Fill with random bytes.
    -s seed
        Seed for the random number generator.
    -u
        Same as -r except os.urandom() is used, providing a
        cryptographically secure set of random bytes.''' % sys.argv[0]

def Usage(status=1):
    print(manual)
    sys.exit(status)

def err(s):
    print(s, file=sys.stderr)

def InterpretSize(s):
    multiplier = 1
    if s[-1] == "k":
        multiplier = 1000
        s = s[:-1]
    elif s[-1] == "M":
        multiplier = 1000*1000
        s = s[:-1]
    elif s[-1] == "G":
        multiplier = 1000*1000*1000
        s = s[:-1]
    try:
        size = int(float(s)*multiplier)
    except Exception:
        err("'%s':  bad size specifier" % s)
        exit(1)
    return size

def ParseCommandLine(d):
    d["-b"] = 0
    d["-r"] = False
    d["-s"] = None
    d["-u"] = False
    if len(sys.argv) < 2:
        Usage()
    try:
        optlist, args = getopt.getopt(sys.argv[1:], "b:rs:u")
    except getopt.GetoptError as str:
        msg, option = str
        print(msg)
        sys.exit(1)
    for opt in optlist:
        if opt[0] == "-b":
            d["-b"] = int(opt[1])
            if not 0 <= d["-b"] < 256:
                err("-b option must be a byte value between 0 and 255")
                exit(1)
        elif opt[0] == "-r":
            d["-r"] = True
        elif opt[0] == "-s":
            d["-s"] = opt[1]
            random.seed(opt[1])
        elif opt[0] == "-u":
            d["-u"] = not d["-u"]
    if len(args) != 2:
        Usage()
    size = InterpretSize(args[0])
    return size, args[1]

def RandomBytes(n):
    for i in range(n):
        yield "{:02x}".format(random.randint(0, 255))

def MakeFile(size, filename, d):
    def WriteBytes(stream, byte, number_of_bytes, random_bytes):
        if random_bytes == 1:
            if 0:
                # This slow method is used because I think there's a bug in
                # what random.getrandbits() returns.
                b = [i for i in RandomBytes(number_of_bytes)]
                assert(len(b) == number_of_bytes)
                stream.write(b''.fromhex(''.join(b)))
            else:
                n = 2*number_of_bytes
                i = random.getrandbits(4*n)
                s = str(hex(i))[2:]
                if len(s) > n:
                    s = s[:n]
                elif len(s) < n:
                    while len(s) < n:
                        s += str(hex(random.getrandbits(1)))[0]
                stream.write(b''.fromhex(s))
        elif random_bytes == 2:
            stream.write(os.urandom(number_of_bytes))
        else:
            stream.write(("%c" % byte)*number_of_bytes)
    random_bytes = 0
    if d["-r"]:
        random_bytes = 1
    if d["-u"]:
        random_bytes = 2
    byte_value = d["-b"]
    # We'll write the file in chunks so that we don't run out of memory for
    # large files.
    try:
        ofp = open(filename, "wb")
    except Exception:
        err("Couldn't open '%s' for writing" % filename)
        exit(1)
    numchunks, remainder = divmod(size, chunksize)
    for i in range(numchunks):
        WriteBytes(ofp, byte_value, chunksize, random_bytes)
    if remainder:
        WriteBytes(ofp, byte_value, remainder, random_bytes)

if __name__ == "__main__":
    d = {}
    size, filename = ParseCommandLine(d)
    MakeFile(size, filename, d)
